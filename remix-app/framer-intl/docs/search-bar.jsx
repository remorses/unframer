// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project f667fc580d8d9346 "ApiFlow (copy)", do not edit manually */
"use client";

/**
 * @typedef Locale
 * string
 */

/**
 * @typedef Props
 * @property {React.ReactNode=} children - The children components.
 * @property {Locale=} locale - The active locale.
 * @property {React.CSSProperties=} style - Component styles.
 * @property {string=} className - Additional class names.
 * @property {string=} id - Component id.
 * @property {*=} width - Component width.
 * @property {*=} height - Component height.
 * @property {string=} layoutId - Layout id.
 * @property {'Desktop' | 'Mobile'} [variant] - Variant
 */

/**
 * @type {import("unframer").UnframerBreakpoint}
 * Represents a responsive breakpoint for unframer.
 */

/**
 * @typedef VariantsMap
 * Partial record of UnframerBreakpoint to Props.variant, with a mandatory 'base' key.
 * { [key in UnframerBreakpoint]?: Props['variant'] } & { base: Props['variant'] }
 */
import { className, css, fonts } from "../chunks/chunk-DOAYAVFF.js";
import { routes } from "../chunks/chunk-6OPQGIC3.js";
import "../chunks/chunk-WSFCRVEQ.js";

// virtual:docs/search-bar
import { Fragment as Fragment2 } from "react";
import { ContextProviders } from "unframer";

// /:https://framerusercontent.com/modules/9UAJj0iki6gynMc1A5PF/lPfa8uJucm8GreYWEGAr/wvuAi9wiC.js
import { jsx as _jsx4, jsxs as _jsxs4 } from "react/jsx-runtime";
import {
	addFonts,
	addPropertyControls as addPropertyControls2,
	ComponentViewportProvider,
	ControlType as ControlType2,
	cx,
	getFonts,
	getFontsFromSharedStyle,
	RichText,
	SVG,
	useComponentViewport,
	useLocaleInfo as useLocaleInfo3,
	useVariantState,
	withCSS as withCSS2,
} from "unframer";
import { LayoutGroup, motion as motion4, MotionConfigContext } from "unframer";
import * as React2 from "react";

// /:https://framerusercontent.com/modules/6wAE2eMb2Tl3zrU7u4UL/HPzg2Uk7mwtBmDzvGbWF/Search.js
import { jsx as _jsx3, jsxs as _jsxs3 } from "react/jsx-runtime";
import { createPortal } from "react-dom";
import {
	useRef as useRef3,
	useState as useState4,
	useEffect as useEffect4,
	forwardRef as forwardRef2,
} from "react";
import { AnimatePresence, motion as motion3 } from "unframer";

// /:https://framerusercontent.com/modules/LV9trClbmNwd5PVj9l8y/L4rFqMGNzGSwRZpGTGF3/Icons.js
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { motion } from "unframer";
function SearchIcon(props) {
	return (
		<svg
			xmlns={"http://www.w3.org/2000/svg"}
			viewBox={"0 0 256 256"}
			width={props.width}
			height={props.height}
			style={{
				...props.style,
				color: props.color,
			}}
		>
			<path
				d={
					"M232.49,215.51,185,168a92.12,92.12,0,1,0-17,17l47.53,47.54a12,12,0,0,0,17-17ZM44,112a68,68,0,1,1,68,68A68.07,68.07,0,0,1,44,112Z"
				}
				fill={"currentColor"}
			/>
		</svg>
	);
}
function ClearIcon(props) {
	return (
		<svg
			xmlns={"http://www.w3.org/2000/svg"}
			viewBox={"0 0 256 256"}
			{...props}
		>
			<rect width={"256"} height={"256"} fill={"none"} />
			<path
				d={
					"M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm37.66,130.34a8,8,0,0,1-11.32,11.32L128,139.31l-26.34,26.35a8,8,0,0,1-11.32-11.32L116.69,128,90.34,101.66a8,8,0,0,1,11.32-11.32L128,116.69l26.34-26.35a8,8,0,0,1,11.32,11.32L139.31,128Z"
				}
				fill={"currentColor"}
			/>
		</svg>
	);
}
function SpinnerIcon(props) {
	const borderWidth = 3;
	return (
		<div
			style={{
				position: "relative",
				...props.style,
			}}
		>
			<motion.div
				animate={{
					rotate: 360,
				}}
				transition={{
					ease: "linear",
					duration: 1,
					repeat: Infinity,
				}}
				style={{
					borderRadius: 100,
					backgroundImage: `conic-gradient(from 270deg, transparent 0%, ${props.color} 100%)`,
					width: "100%",
					height: "100%",
				}}
			/>
			<div
				style={{
					backgroundColor: props.backgroundColor,
					borderRadius: 100,
					position: "absolute",
					top: borderWidth,
					left: borderWidth,
					bottom: borderWidth,
					right: borderWidth,
				}}
			/>
		</div>
	);
}

// /:https://framerusercontent.com/modules/6wAE2eMb2Tl3zrU7u4UL/HPzg2Uk7mwtBmDzvGbWF/Search.js
import {
	addPropertyControls,
	ControlType,
	RenderTarget,
	withCSS,
} from "unframer";

// /:https://framerusercontent.com/modules/tV9haTHllpHHc9Fjue2H/Xy775u0FJg3K1GQc1Cd9/SearchModal.js
import { jsx as _jsx2, jsxs as _jsxs2 } from "react/jsx-runtime";

// /:https://framerusercontent.com/modules/MyBp84Z0p9nUcMimVMnY/y5F4AGWJ6syeuoB7ebKM/useSearch.js
import { useLocaleInfo } from "unframer";
import { clamp } from "unframer";
import { useEffect, useMemo, useState } from "react";

// /:https://framerusercontent.com/modules/3Xi2AslpcDRhfyCVPmx3/d0Oobr5BHnVqZJQyMdGn/storage.js
function Storage(name) {
	this.ready = new Promise((resolve, reject) => {
		var request = window.indexedDB.open(location.origin);
		request.onupgradeneeded = (e) => {
			this.db = e.target["result"];
			this.db.createObjectStore("store");
		};
		request.onsuccess = (e) => {
			this.db = e.target["result"];
			resolve();
		};
		request.onerror = (e) => {
			this.db = e.target["result"];
			reject(e);
		};
	});
}
Storage.prototype.get = function (key) {
	return this.ready.then(() => {
		return new Promise((resolve, reject) => {
			var request = this.getStore().get(key);
			request.onsuccess = (e) => resolve(e.target.result);
			request.onerror = reject;
		});
	});
};
Storage.prototype.getStore = function () {
	return this.db.transaction(["store"], "readwrite").objectStore("store");
};
Storage.prototype.set = function (key, value) {
	return this.ready.then(() => {
		return new Promise((resolve, reject) => {
			var request = this.getStore().put(value, key);
			request.onsuccess = resolve;
			request.onerror = reject;
		});
	});
};
Storage.prototype.delete = function (key, value) {
	window.indexedDB.deleteDatabase(location.origin);
};

// /:https://framer.com/m/cache-YMiL.js@b9aplVZjN51x28yfNK16
async function setCachedData(url, dataToCache, cache = new Storage("cache")) {
	const cacheKey = url;
	const data = await cache.set(cacheKey, dataToCache);
}
async function checkForCachedData(url, cache = new Storage("cache")) {
	const cacheKey = url;
	const data = await cache.get(cacheKey);
	if (data) {
		return data;
	} else {
		return null;
	}
}

// /:https://framerusercontent.com/modules/uU1mtMKXsrVAg8N5hW7w/PCK1x1QLNluYNoEoapwx/cachedIndex.js
var VERSION = 1;
function isDefaultLocaleId(localeId) {
	return !localeId || localeId === "default";
}
var INDEX_KEY = "searchIndexCache";
function getIndexKey(localeId) {
	if (isDefaultLocaleId(localeId)) return INDEX_KEY;
	return `${INDEX_KEY}-${localeId}`;
}
var METADATA_KEY = "searchCacheMetadata";
function getMetadataKey(localeId) {
	if (isDefaultLocaleId(localeId)) return METADATA_KEY;
	return `${METADATA_KEY}-${localeId}`;
}
async function getCachedIndex(localeId) {
	const indexKey = getIndexKey(localeId);
	const cachedIndex = await checkForCachedData(indexKey);
	if (cachedIndex) {
		return cachedIndex;
	}
}
function setCachedIndex(localeId, index) {
	const indexKey = getIndexKey(localeId);
	setCachedData(indexKey, index);
	const metadata = {
		version: VERSION,
		timestamp: Date.now(),
	};
	const metadataKey = getMetadataKey(localeId);
	setCachedData(metadataKey, metadata);
}

// /:https://framerusercontent.com/modules/K9JZRwJcE6slDAf8rUmh/mJ54py1Ecnn1RoC4N1m4/fakeResults.js
var fakeResults = {
	"/": {
		version: 1,
		title: "Example Search Result",
		description: "Description of search result.",
		keywords: "",
		h1: [],
		h2: [],
		h3: [],
		h4: [],
		h5: [],
		h6: [],
		p: [],
		url: "/example-url/",
		codeblock: [],
	},
	"/example-1": {
		version: 1,
		title: "Publish your Site to Search",
		description:
			"Try Site Search to instantly search your Framer site content.",
		keywords: "",
		h1: [],
		h2: [],
		h3: [],
		h4: [],
		h5: [],
		h6: [],
		p: [],
		url: "/example-url/1/",
		codeblock: [],
	},
	"/example-2": {
		version: 1,
		title: "Customise your Site Search",
		description: "Personalize everything from corner radius, to icon weight.",
		keywords: "",
		h1: [],
		h2: [],
		h3: [],
		h4: [],
		h5: [],
		h6: [],
		p: [],
		url: "/example-url/2/",
		codeblock: [],
	},
};

// /:https://framerusercontent.com/modules/TwRgbWuhHeB95MPifel4/YW8Hlm59FG3PajbrVsaR/fuzzySearch.js
var peq = new Uint32Array(65536);
var myers_32 = (a, b) => {
	const n = a.length;
	const m = b.length;
	const lst = 1 << (n - 1);
	let pv = -1;
	let mv = 0;
	let sc = n;
	let i = n;
	while (i--) {
		peq[a.charCodeAt(i)] |= 1 << i;
	}
	for (i = 0; i < m; i++) {
		let eq = peq[b.charCodeAt(i)];
		const xv = eq | mv;
		eq |= ((eq & pv) + pv) ^ pv;
		mv |= ~(eq | pv);
		pv &= eq;
		if (mv & lst) {
			sc++;
		}
		if (pv & lst) {
			sc--;
		}
		mv = (mv << 1) | 1;
		pv = (pv << 1) | ~(xv | mv);
		mv &= xv;
	}
	i = n;
	while (i--) {
		peq[a.charCodeAt(i)] = 0;
	}
	return sc;
};
var myers_x = (b, a) => {
	const n = a.length;
	const m = b.length;
	const mhc = [];
	const phc = [];
	const hsize = Math.ceil(n / 32);
	const vsize = Math.ceil(m / 32);
	for (let i = 0; i < hsize; i++) {
		phc[i] = -1;
		mhc[i] = 0;
	}
	let j = 0;
	for (; j < vsize - 1; j++) {
		let mv = 0;
		let pv = -1;
		const start = j * 32;
		const vlen = Math.min(32, m) + start;
		for (let k = start; k < vlen; k++) {
			peq[b.charCodeAt(k)] |= 1 << k;
		}
		for (let i1 = 0; i1 < n; i1++) {
			const eq = peq[a.charCodeAt(i1)];
			const pb = (phc[(i1 / 32) | 0] >>> i1) & 1;
			const mb = (mhc[(i1 / 32) | 0] >>> i1) & 1;
			const xv = eq | mv;
			const xh = ((((eq | mb) & pv) + pv) ^ pv) | eq | mb;
			let ph = mv | ~(xh | pv);
			let mh = pv & xh;
			if ((ph >>> 31) ^ pb) {
				phc[(i1 / 32) | 0] ^= 1 << i1;
			}
			if ((mh >>> 31) ^ mb) {
				mhc[(i1 / 32) | 0] ^= 1 << i1;
			}
			ph = (ph << 1) | pb;
			mh = (mh << 1) | mb;
			pv = mh | ~(xv | ph);
			mv = ph & xv;
		}
		for (let k1 = start; k1 < vlen; k1++) {
			peq[b.charCodeAt(k1)] = 0;
		}
	}
	let mv1 = 0;
	let pv1 = -1;
	const start1 = j * 32;
	const vlen1 = Math.min(32, m - start1) + start1;
	for (let k2 = start1; k2 < vlen1; k2++) {
		peq[b.charCodeAt(k2)] |= 1 << k2;
	}
	let score = m;
	for (let i2 = 0; i2 < n; i2++) {
		const eq1 = peq[a.charCodeAt(i2)];
		const pb1 = (phc[(i2 / 32) | 0] >>> i2) & 1;
		const mb1 = (mhc[(i2 / 32) | 0] >>> i2) & 1;
		const xv1 = eq1 | mv1;
		const xh1 = ((((eq1 | mb1) & pv1) + pv1) ^ pv1) | eq1 | mb1;
		let ph1 = mv1 | ~(xh1 | pv1);
		let mh1 = pv1 & xh1;
		score += (ph1 >>> (m - 1)) & 1;
		score -= (mh1 >>> (m - 1)) & 1;
		if ((ph1 >>> 31) ^ pb1) {
			phc[(i2 / 32) | 0] ^= 1 << i2;
		}
		if ((mh1 >>> 31) ^ mb1) {
			mhc[(i2 / 32) | 0] ^= 1 << i2;
		}
		ph1 = (ph1 << 1) | pb1;
		mh1 = (mh1 << 1) | mb1;
		pv1 = mh1 | ~(xv1 | ph1);
		mv1 = ph1 & xv1;
	}
	for (let k3 = start1; k3 < vlen1; k3++) {
		peq[b.charCodeAt(k3)] = 0;
	}
	return score;
};
var distance = (a, b) => {
	if (a.length < b.length) {
		const tmp = b;
		b = a;
		a = tmp;
	}
	if (b.length === 0) {
		return a.length;
	}
	if (a.length <= 32) {
		return myers_32(a, b);
	}
	return myers_x(a, b);
};

// /:https://framerusercontent.com/modules/MWsEnYfRnoOQq31DN4ql/C71JVnvNwV2CrPvApXBB/utils.js
var localStorageDebugFlag =
	typeof window !== "undefined" &&
	window.localStorage.getItem("__framerDebugSearch") === "true";
var groupsRegex = /[A-Z]{2,}|[A-Z][a-z]+|[a-z]+|[A-Z]\d*|\d+/gu;
function capitalizeFirstLetter(value) {
	return value.charAt(0).toUpperCase() + value.slice(1);
}
function titleCase(value) {
	const groups = value.match(groupsRegex) || [];
	return groups.map(capitalizeFirstLetter).join(" ");
}
function clampText(text, maxLength) {
	const textLength = text.length;
	if (textLength <= maxLength) {
		return text;
	}
	const slicedText = text.slice(0, maxLength);
	if (textLength > maxLength) {
		return slicedText + "\u2026";
	}
	return slicedText;
}
function isEmptyObject(object) {
	return Object.keys(object).length === 0;
}
function createLogger(showOutput) {
	function log2(...data) {
		console.log(Date.now(), ...data);
	}
	function time2(label) {
		console.time(label);
	}
	function timeEnd2(label) {
		console.timeEnd(label);
	}
	function noop() {}
	if (!showOutput) {
		return {
			log: noop,
			time: noop,
			timeEnd: noop,
		};
	}
	return {
		log: log2,
		time: time2,
		timeEnd: timeEnd2,
	};
}
var DEFAULT_FONT_FAMILY = `"Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
function getFontFamily(theme) {
	var _theme_inputFont, _theme_titleFont, _theme_subtitleFont;
	if (
		(_theme_inputFont = theme.inputFont) === null || _theme_inputFont === void 0
			? void 0
			: _theme_inputFont.fontFamily
	)
		return theme.inputFont.fontFamily;
	if (
		(_theme_titleFont = theme.titleFont) === null || _theme_titleFont === void 0
			? void 0
			: _theme_titleFont.fontFamily
	)
		return theme.titleFont.fontFamily;
	if (
		(_theme_subtitleFont = theme.subtitleFont) === null ||
		_theme_subtitleFont === void 0
			? void 0
			: _theme_subtitleFont.fontFamily
	)
		return theme.subtitleFont.fontFamily;
	return DEFAULT_FONT_FAMILY;
}
function animationKeyFromLayout(layout) {
	return `${layout}Animation`;
}
var safeDocument = typeof document !== "undefined" ? document : null;
var safeWindow = typeof window !== "undefined" ? window : null;
var metaTagSelector = 'meta[name="framer-search-index"]';
function getMetaTagContent() {
	const metaTag =
		safeDocument === null || safeDocument === void 0
			? void 0
			: safeDocument.querySelector(metaTagSelector);
	if (!metaTag) return void 0;
	const metaTagContent = metaTag.getAttribute("content");
	return metaTagContent;
}
var checkIfOverLimit = () => {
	return getMetaTagContent() === "limit-reached";
};
function stripLocaleSlugFromPath(url, localeSlug) {
	if (!localeSlug) return url;
	const localeSlugWithSlash = `/${localeSlug}`;
	if (url.startsWith(localeSlugWithSlash)) {
		return url.slice(localeSlugWithSlash.length);
	}
}

// /:https://framerusercontent.com/modules/MyBp84Z0p9nUcMimVMnY/y5F4AGWJ6syeuoB7ebKM/useSearch.js
var { log, time, timeEnd } = createLogger(localStorageDebugFlag);
function isValidUrl(url) {
	try {
		new URL(url);
		return true;
	} catch (_error) {
		return false;
	}
}
function splitWords(text) {
	try {
		return text.split(
			RegExp("[\\s.,;!?\\p{P}\\p{Z}]+(?<!\\p{L}&)(?!&\\p{L})", "u"),
		);
	} catch {
		log("Falling back to regex without lookbehind");
		return text.split(RegExp("[\\s.,;!?\\p{P}\\p{Z}]+", "u"));
	}
}
function getUniqueWords(str) {
	const words = splitWords(str).filter(
		(word) => word.trim() && word.length > 0,
	);
	return new Set(words);
}
function getNormalizedString(text) {
	if (Array.isArray(text)) {
		return text.map(getNormalizedString);
	}
	return text
		.normalize("NFD")
		.replace(/[\u0300-\u036f]/g, "")
		.toLowerCase();
}
function getNormalizedItem(item) {
	const normalizedItem = {};
	for (const [key, value] of Object.entries(item)) {
		if (typeof value === "string") {
			normalizedItem[key] = getNormalizedString(value);
			continue;
		}
		if (Array.isArray(value)) {
			normalizedItem[key] = getNormalizedString(value);
			continue;
		}
		normalizedItem[key] = value;
	}
	return normalizedItem;
}
function getMatchRange(currentRange, start, end) {
	const result = {
		...currentRange,
	};
	if (start < result.start) {
		result.start = start;
	}
	if (end > result.end) {
		result.end = end;
	}
	return result;
}
function getScoreForSearchIndexItem(item, query, words, fullQuery) {
	let score = 0;
	const match = {
		title: {
			start: Infinity,
			end: 0,
		},
		description: {
			start: Infinity,
			end: 0,
		},
	};
	const urlWords = getUniqueWords(item.url);
	if (urlWords.has(query)) {
		score += 10;
	}
	if (
		words.size === 1 &&
		urlWords.size === 1 &&
		urlWords.values().next().value === query
	) {
		score += score * 5;
	}
	if (score > 0) {
		const splitLength = item.url.split("/").length;
		score += clamp(10 - splitLength, 0, splitLength);
	}
	const titleWords = getUniqueWords(item.title);
	if (titleWords.has(query)) {
		score += 10;
	}
	const titleIndex = item.title.indexOf(query);
	if (titleIndex !== -1) {
		score += 10;
		match.title = getMatchRange(
			match.title,
			titleIndex,
			titleIndex + query.length,
		);
	}
	if (distance(item.title, fullQuery) <= 2) {
		score += score * 10;
	}
	for (const titleWord of titleWords) {
		const distanceScore = distance(query, titleWord);
		if (distanceScore <= 2) {
			score += 10;
		}
	}
	const headings = [
		...item.h1,
		...item.h2,
		...item.h3,
		...item.h4,
		...item.h5,
		...item.h6,
	];
	for (const heading of headings) {
		const headingWords = getUniqueWords(heading);
		if (distance(heading, fullQuery) <= 2) {
			score += score * 10;
		}
		if (heading.startsWith(query)) {
			score += 10;
		}
		if (headingWords.has(query)) {
			score += 10;
		}
		if (heading.includes(query)) {
			score += 1;
		}
		for (const headingWord of headingWords) {
			const distanceScore = distance(query, headingWord);
			if (distanceScore <= 2) {
				score += 1;
			}
		}
	}
	const descriptionIndex = item.description.indexOf(query);
	if (descriptionIndex !== -1) {
		score += 10;
		match.description = getMatchRange(
			match.description,
			descriptionIndex,
			descriptionIndex + query.length,
		);
	}
	for (const p of item.p) {
		if (p.includes(query)) {
			score += 0.5;
		}
	}
	for (const codeblock of item.codeblock) {
		if (distance(codeblock, fullQuery) <= 2) {
			score *= 10;
		}
		if (codeblock.includes(fullQuery)) {
			score += 10;
		}
		if (codeblock.includes(query)) {
			score += 0.5;
		}
	}
	return {
		score,
		match,
	};
}
function getSearchIndexItemScore(item, query) {
	const normalizedItem = getNormalizedItem(item);
	const normalizedQuery = getNormalizedString(query);
	const queryWords = getUniqueWords(normalizedQuery);
	let total = 0;
	for (const queryWord of queryWords) {
		const { score } = getScoreForSearchIndexItem(
			normalizedItem,
			queryWord,
			queryWords,
			normalizedQuery,
		);
		total += score;
	}
	return total;
}
function useRawSearch(index, query, settings) {
	const results = useMemo(() => {
		if (!query || !index) {
			return [];
		}
		const path =
			safeWindow === null || safeWindow === void 0
				? void 0
				: safeWindow.location.pathname;
		time("query");
		const results2 = Object.values(index)
			.map((item) => {
				const score = getSearchIndexItemScore(item, query);
				const heading = item.h1.length && item.h1[0];
				const title =
					(settings === null || settings === void 0
						? void 0
						: settings.titleType) === SearchResultTitleType.Title
						? item.title
						: heading
							? heading
							: item.title;
				const result = {
					url: item.url,
					title,
					description: item.description,
					body: [...item.p, item.codeblock].join(" "),
					score,
				};
				return result;
			})
			.filter((item) => item.score > settings.minimumScore || 0)
			.filter((item) => {
				if (!path) return true;
				return item.url !== path;
			})
			.sort((itemA, itemB) => itemB.score - itemA.score);
		timeEnd("query");
		return results2;
	}, [index, query]);
	return results;
}
function getIndexedScopedToUrl(index, rawUrlScope, localeSlug) {
	const scopedIndex = {};
	const baseScopeUrlHasVariable = rawUrlScope.includes(":");
	const urlUpToPathVariable = rawUrlScope.split(":")[0];
	const urlScope = urlUpToPathVariable.length > 1 ? urlUpToPathVariable : "";
	for (const url in index) {
		const strippedURL = stripLocaleSlugFromPath(url, localeSlug);
		if (!strippedURL.startsWith(urlScope)) {
			continue;
		}
		if (baseScopeUrlHasVariable && url.length <= urlScope.length) {
			continue;
		}
		scopedIndex[url] = index[url];
	}
	return scopedIndex;
}
function useSearch(query, settings) {
	const [searchIndex, _setSearchIndex] = useState({});
	const [status, setStatus] = useState("loading");
	const results = useRawSearch(searchIndex, query, settings);
	const { activeLocale } = useLocaleInfo();
	const localeId =
		activeLocale === null || activeLocale === void 0 ? void 0 : activeLocale.id;
	function setSearchIndex(
		index,
		options = {
			ignoreScope: false,
		},
	) {
		let scopedIndex = index;
		if (settings.urlScope && !options.ignoreScope) {
			scopedIndex = getIndexedScopedToUrl(
				index,
				settings.urlScope,
				activeLocale === null || activeLocale === void 0
					? void 0
					: activeLocale.slug,
			);
			log("Using URL scope", settings.urlScope);
		}
		_setSearchIndex(scopedIndex);
	}
	useEffect(() => {
		async function loadSearchIndex() {
			setStatus("loading");
			const metaTag =
				safeDocument === null || safeDocument === void 0
					? void 0
					: safeDocument.querySelector('meta[name="framer-search-index"]');
			if (!metaTag) {
				setStatus("no-meta-tag-found");
				setSearchIndex(fakeResults, {
					ignoreScope: true,
				});
				log("No meta tag found");
				return;
			}
			const cachedIndex = await getCachedIndex(localeId);
			const metaTagContent = metaTag.getAttribute("content");
			const isOverLimit = metaTagContent === "limit-reached";
			if (isOverLimit) {
				log("Page limit for plan exceeded");
			}
			if (cachedIndex && !isOverLimit) {
				setSearchIndex(cachedIndex);
				setStatus("loading-with-cache");
				log("Using cached index");
			}
			if (!metaTagContent || !isValidUrl(metaTagContent)) {
				log("Meta tag exists but URL is not valid yet");
				if (!cachedIndex) {
					setStatus("pending-index-generation");
					log("No cache to use, page reload required to check for meta tag");
				} else {
					log("Continue using cache");
				}
				return;
			}
			const searchIndexURL = getSearchIndexURL(metaTagContent, localeId);
			const response = await fetch(searchIndexURL);
			if (!response.ok) {
				throw new Error(response.statusText);
			}
			const downloadedIndex = await response.json();
			setSearchIndex(downloadedIndex);
			setCachedIndex(localeId, downloadedIndex);
			setStatus("success");
			log("Using downloaded index");
		}
		loadSearchIndex().catch((error) => {
			setStatus("error");
			log("Failed to load search index", error);
		});
	}, [localeId]);
	log({
		status,
		results,
	});
	return {
		results,
		status,
	};
}
function getSearchIndexURL(baseURL, localeId) {
	if (isDefaultLocaleId(localeId)) return baseURL;
	return baseURL.replace(".json", `-${localeId}.json`);
}

// /:https://framerusercontent.com/modules/tV9haTHllpHHc9Fjue2H/Xy775u0FJg3K1GQc1Cd9/SearchModal.js
import React, {
	useEffect as useEffect2,
	useState as useState2,
	useMemo as useMemo2,
	forwardRef,
	useRef as useRef2,
	useDeferredValue,
	useLayoutEffect,
	useCallback as useCallback2,
	useImperativeHandle,
} from "react";

// /:https://framerusercontent.com/modules/PJVBcBLmDteTEAZh3J9Z/keXJyjyE9VnzUcDMayjg/browser.js
var __unframerNavigator = typeof window !== "undefined" ? navigator : void 0;
var Browser;
(function (Browser2) {
	var isTouch = (Browser2.isTouch = () =>
		"ontouchstart" in window || __unframerNavigator.maxTouchPoints > 0);
	var isChrome = (Browser2.isChrome = () =>
		__unframerNavigator.userAgent.toLowerCase().includes("chrome/"));
	var isWebKit = (Browser2.isWebKit = () =>
		__unframerNavigator.userAgent.toLowerCase().includes("applewebkit/"));
	var isSafari = (Browser2.isSafari = () => isWebKit() && !isChrome());
	var isSafariDesktop = (Browser2.isSafariDesktop = () =>
		isSafari() && !isTouch());
	var isWindows = (Browser2.isWindows = () =>
		/Win/.test(__unframerNavigator.platform));
	var isMacOS = (Browser2.isMacOS = () =>
		/Mac/.test(__unframerNavigator.platform));
})(Browser || (Browser = {}));

// /:https://framerusercontent.com/modules/tV9haTHllpHHc9Fjue2H/Xy775u0FJg3K1GQc1Cd9/SearchModal.js
import { motion as motion2, clamp as clamp2, useAnimate } from "unframer";

// /:https://framerusercontent.com/modules/Gzef0nFihI9m9vZG45th/lIUxbZcreiDm2GzUkt3y/useCallbackOnMouseMove.js
import { useRef, useCallback } from "react";
var useCallbackOnMouseMove = (callback, mousePositionRef) => {
	const prevPositionRef = useRef(null);
	return useCallback(
		(event) => {
			if (!Browser.isSafari()) return callback(event);
			const ref = mousePositionRef ? mousePositionRef : prevPositionRef;
			const { clientX, clientY } = event;
			const prevCursorPosition = ref.current;
			ref.current = {
				x: clientX,
				y: clientY,
			};
			if (!prevCursorPosition) {
				return;
			}
			if (
				prevCursorPosition.x !== clientX ||
				prevCursorPosition.y !== clientY
			) {
				return callback(event);
			}
		},
		[mousePositionRef, callback],
	);
};

// /:https://framerusercontent.com/modules/eAnjm75CdfYT1Zz4BIaz/7KDSfnnyD1T3Ap75L4m8/scrollIntoView.js
function scrollIntoView(
	targetElement,
	scrollElement,
	{ offsetTop, offsetBottom },
) {
	const targetElementBounds = targetElement.getBoundingClientRect();
	const scrollElementBounds = scrollElement.getBoundingClientRect();
	if (targetElementBounds.top < scrollElementBounds.top) {
		const difference = scrollElementBounds.top - targetElementBounds.top;
		scrollElement.scrollTop = scrollElement.scrollTop - difference - offsetTop;
	} else if (targetElementBounds.bottom > scrollElementBounds.bottom) {
		const topAligned = scrollElementBounds.top - targetElementBounds.top;
		const minOffset = scrollElement.scrollTop - topAligned - offsetTop;
		const bottomAligned =
			targetElementBounds.bottom - scrollElementBounds.bottom;
		const offset = scrollElement.scrollTop + bottomAligned + offsetBottom;
		scrollElement.scrollTop = Math.min(minOffset, offset);
	}
}

// /:https://framerusercontent.com/modules/tV9haTHllpHHc9Fjue2H/Xy775u0FJg3K1GQc1Cd9/SearchModal.js
import {
	useLocaleInfo as useLocaleInfo2,
	useRouter,
	inferInitialRouteFromPath,
} from "unframer";
var MAX_DESCRIPTION_LENGTH = 120;
var MODAL_MAX_HEIGHT = 496;
var VERTICAL_SPACING_MULTIPLIER = 0.6;
function ClearButton({ theme, type, onClick, text }) {
	const shouldDisplayIcon = type === "icon";
	const iconOrText = shouldDisplayIcon ? (
		<ClearIcon
			style={{
				color: theme.inputIconColor,
				width: theme.inputIconSize,
				height: theme.inputIconSize,
			}}
		/>
	) : (
		text
	);
	return (
		<div
			style={{
				flexShrink: 0,
				fontSize:
					theme && theme.titleFont && theme.titleFont.fontSize
						? theme.titleFont.fontSize
						: 15,
			}}
		>
			<button
				className={"__framer-search-clear-button"}
				onClick={onClick}
				style={{
					fontFamily: "inherit",
					border: "none",
					background: "none",
					cursor: "pointer",
					display: "flex",
					textTransform: "uppercase",
					color: theme.inputIconColor,
					fontSize: "0.75em",
					padding: 0,
				}}
			>
				{iconOrText}
			</button>
		</div>
	);
}
function Divider({ theme, type }) {
	const styles = {
		background: theme.foregroundColor,
		height: 1,
		flexShrink: 0,
		opacity: 0.05,
	};
	if (type === "contained" && theme) {
		styles.marginLeft = theme.horizontalSpacing;
		styles.marginRight = theme.horizontalSpacing;
	}
	return <div style={styles} />;
}
var Input = /* @__PURE__ */ forwardRef(function Input2(props, ref) {
	const {
		value = "",
		status,
		autofocus,
		theme,
		placeholder,
		iconType,
		clearButtonType,
		onChange,
	} = props;
	const [inputValue, setInputValue] = useState2(value);
	const [isFocused, setIsFocused] = useState2(false);
	const inputRef = useRef2();
	useImperativeHandle(ref, () => inputRef.current);
	React.useLayoutEffect(() => {
		return () => {
			const inputElement = inputRef.current;
			if (!inputElement || inputElement !== document.activeElement) return;
			inputElement.blur();
		};
	}, []);
	const handleInputClick = () => {
		if (inputRef.current) {
			inputRef.current.focus();
		}
	};
	const handleClearClick = () => {
		setInputValue("");
	};
	useEffect2(() => {
		onChange(inputValue);
	}, [inputValue]);
	const hasInputText = inputValue.length > 0;
	const showClearButton =
		inputValue.length > 0 && clearButtonType && clearButtonType !== "none";
	const verticalSpacing = Math.floor(
		theme ? theme.horizontalSpacing * VERTICAL_SPACING_MULTIPLIER : 0,
	);
	const searchIcon =
		iconType === "custom" && theme.inputIconImage ? (
			<img
				alt={"icon alongside the Site Search input"}
				src={theme.inputIconImage.src}
				width={theme.inputIconSize}
				height={theme.inputIconSize}
			/>
		) : (
			<SearchIcon
				color={theme.inputIconColor}
				width={theme.inputIconSize}
				height={theme.inputIconSize}
			/>
		);
	return (
		<div
			role={"search"}
			style={{
				...inputContainerStyle,
				fontFamily: getFontFamily(theme),
				paddingLeft: theme && theme.horizontalSpacing,
				paddingRight: theme && theme.horizontalSpacing,
				gap: 12,
				paddingTop: verticalSpacing,
				paddingBottom: verticalSpacing,
				touchAction: "none",
			}}
			onClick={handleInputClick}
		>
			<div
				style={{
					flexShrink: 0,
					display: "flex",
				}}
			>
				{status === "loading" && inputValue ? (
					<SpinnerIcon
						color={theme.inputIconColor}
						backgroundColor={theme.backgroundColor}
						style={{
							height: theme && theme.inputIconSize,
							width: theme && theme.inputIconSize,
						}}
					/>
				) : (
					searchIcon
				)}
			</div>
			<input
				ref={inputRef}
				spellCheck={false}
				autoFocus={autofocus}
				style={{
					...inputStyle,
					WebkitTapHighlightColor: "rgba(0,0,0,0)",
					color: theme.foregroundColor,
					lineHeight: "2em",
					verticalAlign: "baseline",
					...theme.titleFont,
					...theme.inputFont,
					fontSize: theme.inputFontSize,
					// @ts-ignore
					"--framer-search-placeholder-color": theme.placeholderColor,
				}}
				onFocus={() => {
					const scrollOffset = document.documentElement.scrollTop;
					document.documentElement.scrollTop = scrollOffset;
				}}
				placeholder={placeholder}
				value={inputValue}
				onChange={() => setInputValue(inputRef.current.value)}
			/>
			{showClearButton && (
				<ClearButton
					theme={theme}
					type={props.clearButtonType}
					text={props.clearButtonText}
					onClick={handleClearClick}
				/>
			)}
		</div>
	);
});
var inputContainerStyle = {
	display: "inline-flex",
	alignItems: "center",
	flexShrink: 0,
};
var inputStyle = {
	outline: "none",
	border: "none",
	background: "transparent",
	fontWeight: 500,
	height: "2em",
	padding: 0,
	width: "100%",
};
var ResultRow = /* @__PURE__ */ React.memo(
	/* @__PURE__ */ React.forwardRef(function ResultRow2(props, ref) {
		const {
			index,
			result,
			prevMousePositionRef,
			type = "contained",
			subtitleType = "path",
			selected = false,
			theme,
			localeSlug,
			style,
			onMouseMove,
			onPointerDown,
			onNavigateTo,
		} = props;
		const { url, title, score } = result;
		const urlPath = useMemo2(() => {
			return stripLocaleSlugFromPath(url, localeSlug);
		}, [url, localeSlug]);
		const handleMouseMove = useCallbackOnMouseMove(
			(event) => onMouseMove(event, index),
			prevMousePositionRef,
		);
		const isContained = type === "contained";
		const borderRadius = isContained
			? clamp2(0, Infinity, theme.borderRadius - theme.spacing)
			: 0;
		const subtitleText =
			subtitleType === "path"
				? urlPath
				: clampText(result.description, MAX_DESCRIPTION_LENGTH);
		const handleClick = (event) => {
			event.preventDefault();
			onNavigateTo(result.url);
		};
		const focusTrap = (event) => {
			event.preventDefault();
		};
		return (
			<a
				ref={ref}
				style={{
					textDecoration: "none",
				}}
				href={result.url}
				onClick={handleClick}
				onMouseMove={handleMouseMove}
				onMouseDown={focusTrap}
				onPointerDown={(event) => onPointerDown(event, index)}
			>
				<li
					style={{
						...resultContainer,
						...style,
						paddingTop: isContained ? 12 : 16,
						paddingBottom: isContained ? 12 : 16,
						color: theme.foregroundColor,
						position: "relative",
						paddingLeft: theme && theme.horizontalSpacing,
						paddingRight: theme && theme.horizontalSpacing,
					}}
				>
					<div
						style={{
							backgroundColor: theme.foregroundColor,
							position: "absolute",
							opacity: selected ? 0.06 : 0,
							borderRadius,
							left: theme && isContained ? theme.spacing : 0,
							right: theme && isContained ? theme.spacing : 0,
							top: 0,
							bottom: 0,
						}}
					/>
					<div
						style={{
							display: "flex",
							flexDirection: "column",
							overflow: "hidden",
							gap: 4,
						}}
					>
						<h3
							style={{
								...resultTitle,
								...theme.titleFont,
								lineHeight: "1.4em",
							}}
						>
							{title}
						</h3>
						<p
							style={{
								margin: 0,
								color: theme.subtitleColor,
								...theme.subtitleFont,
								whiteSpace: "nowrap",
								overflow: "hidden",
								textOverflow: "ellipsis",
								lineHeight: "1.4em",
							}}
						>
							{localStorageDebugFlag ? score : ""} {subtitleText}
						</p>
					</div>
				</li>
			</a>
		);
	}),
);
function QuickMenuSpacer({ onClick }) {
	return (
		<div
			style={{
				width: "100%",
				flexBasis: "20vh",
			}}
			onClick={onClick}
		/>
	);
}
var layoutContainerStyle = {
	display: "flex",
	flexDirection: "column",
	alignItems: "center",
	justifyContent: "flex-start",
	gap: 15,
	overflow: "visible",
};
function LayoutContainer({
	layoutType,
	theme,
	onKeyDown,
	onDismiss,
	children,
	modalOptions,
}) {
	const layoutStyles = getLayoutBaseStyles(layoutType, theme);
	const style = {
		...layoutContainerStyle,
		...layoutStyles,
		willChange: "transform",
		marginTop: layoutType === "FixedTop" ? theme.offsetTop : 0,
		height: layoutType === "Sidebar" ? "100%" : "auto",
		maxHeight: layoutType === "QuickMenu" ? "100%" : "none",
		justifyContent: layoutType === "Sidebar" ? "flex-end" : "flex-start",
		flexDirection: layoutType === "Sidebar" ? "column-reverse" : "column",
	};
	const innerStyle = {
		...layoutContainerStyle,
		...layoutStyles,
		height: layoutType === "Sidebar" ? "100%" : "auto",
		maxHeight: layoutType === "QuickMenu" ? "100%" : "none",
		gap: layoutType === "Sidebar" ? 0 : theme.gapBetweenStatusAndSearch,
		backgroundColor:
			layoutType === "Sidebar" ? theme.backgroundColor : "transparent",
		justifyContent: layoutType === "Sidebar" ? "flex-end" : "flex-start",
		flexDirection: layoutType === "Sidebar" ? "column-reverse" : "column",
		originX: 0.5,
		originY: 0.5,
	};
	function getContainerAnimation() {
		switch (layoutType) {
			case "FixedTop": {
				const key = animationKeyFromLayout("FixedTop");
				const prop = modalOptions ? modalOptions[key] : void 0;
				if (prop) {
					return prop;
				} else {
					return {
						y: -10,
						opacity: 0.2,
						transition: {
							duration: Browser.isTouch() ? 0 : 0.15,
						},
					};
				}
				break;
			}
			case "QuickMenu": {
				const key = animationKeyFromLayout("QuickMenu");
				const prop = modalOptions ? modalOptions[key] : void 0;
				if (prop) {
					return prop;
				} else {
					return {
						scale: 0.95,
						opacity: 0,
						y: 0,
						x: 0,
						rotate: 0,
						transition: {
							type: "spring",
							stiffness: 600,
							damping: 40,
						},
					};
				}
				break;
			}
			case "Sidebar": {
				const key = animationKeyFromLayout("Sidebar");
				const prop = modalOptions ? modalOptions[key] : void 0;
				if (prop) {
					return prop;
				} else {
					return {
						x: -10,
						opacity: 0,
						transition: {
							duration: 0.15,
						},
					};
				}
				break;
			}
		}
	}
	const containerAnimation = getContainerAnimation();
	return (
		<div
			style={style}
			onKeyDown={onKeyDown}
			onClick={(event) => event.stopPropagation()}
		>
			{layoutType === "QuickMenu" && <QuickMenuSpacer onClick={onDismiss} />}
			<motion2.div
				initial={containerAnimation}
				animate={{
					opacity: 1,
					scale: 1,
					x: 0,
					y: 0,
					rotate: 0,
				}}
				transition={containerAnimation ? containerAnimation.transition : void 0}
				exit={{
					opacity: 0,
					transition: {
						duration: 0,
					},
				}}
				style={innerStyle}
			>
				{children}
			</motion2.div>
		</div>
	);
}
function ModalContainer({
	layoutType,
	theme,
	children,
	heightIsStatic,
	heightTransition,
	heightDeps,
}) {
	const style = {
		// This `willChange` is required to avoid weird rendering issues where
		// parts of the search window won't redraw, which we observed in Safari 16.4.
		willChange: "transform",
		backgroundColor: theme.backgroundColor,
		color: theme.foregroundColor,
		borderRadius: layoutType === "QuickMenu" ? theme.borderRadius : 0,
		width: "100%",
		display: "flex",
		flexDirection: "column",
		overflow: "hidden",
		boxShadow: layoutType !== "Sidebar" ? theme.shadow : void 0,
		maxHeight:
			layoutType === "QuickMenu"
				? `min(${MODAL_MAX_HEIGHT}px, calc(100vh - 30px))`
				: void 0,
	};
	const [scope, animate] = useAnimate();
	useLayoutEffect(() => {
		if (layoutType !== "QuickMenu" || heightIsStatic) return;
		const prevHeight = scope.current.offsetHeight;
		scope.current.style.height = "auto";
		const height = scope.current.offsetHeight;
		scope.current.style.height = prevHeight + "px";
		animate(
			scope.current,
			{
				height: [prevHeight, height],
			},
			heightTransition,
		);
	}, heightDeps);
	return (
		<div
			ref={scope}
			role={"dialog"}
			className={
				layoutType === "FixedTop" ? "__framer-max-height-80dvh" : void 0
			}
			style={style}
		>
			{children}
		</div>
	);
}
var ScrollView = /* @__PURE__ */ React.forwardRef(function ScrollView2(
	{ theme, children },
	ref,
) {
	const isTouch = Browser.isTouch();
	const [canScroll, setCanScroll] = React.useState(true);
	React.useEffect(() => {
		if (!isTouch) return;
		const element = ref.current;
		if (!element) return;
		setCanScroll(element.scrollHeight > element.clientHeight);
	});
	return (
		<div
			ref={ref}
			style={{
				width: `calc(100% + ${theme.scrollBarWidth}px)`,
				overflowY: "scroll",
				overflowX: "hidden",
				overscrollBehavior: "contain",
				touchAction: canScroll ? void 0 : "none",
				// Make the list appear slightly under the divider
				// so that the divider is still visible when the first
				// item is selected.
				marginTop: -1,
			}}
		>
			{children}
		</div>
	);
});
var statusStyle = {
	backgroundColor: "#B5B5B5",
	color: "#FFF",
	boxShadow: "0px 20px 40px 0px rgba(0, 0, 0, 0.25)",
	fontFamily: "inherit",
	textAlign: "center",
	fontSize: 13,
	padding: "8px 0",
};
function StatusMessage({ status, layoutType, theme }) {
	const verticalSpacing = Math.floor(
		theme ? theme.horizontalSpacing * VERTICAL_SPACING_MULTIPLIER : 0,
	);
	const style = {
		...statusStyle,
		userSelect: "none",
		fontFamily: getFontFamily(theme),
		paddingLeft: theme && theme.horizontalSpacing,
		paddingRight: theme && theme.horizontalSpacing,
		fontWeight: 500,
		lineHeight: `calc(${theme.inputFontSize} * 2)`,
		paddingTop: verticalSpacing,
		paddingBottom: verticalSpacing,
		...theme.titleFont,
		zIndex: theme.zIndex + 1,
		maxWidth: layoutType === "FixedTop" ? "none" : theme.width,
		width:
			layoutType === "FixedTop"
				? `calc(100% - ${verticalSpacing * 2}px`
				: "100%",
		boxShadow: layoutType !== "Sidebar" && statusStyle.boxShadow,
		borderRadius: layoutType !== "Sidebar" && theme.borderRadius,
	};
	const previewInfoText =
		layoutType === "FixedTop"
			? "Preview Mode"
			: "Preview Mode. Publish your Site to Search.";
	if (status === "no-meta-tag-found") {
		return <div style={style}>{previewInfoText}</div>;
	}
	if (status === "pending-index-generation") {
		return <div style={style}>{"Site is being indexed"}</div>;
	}
	return null;
}
var resultTitle = {
	textOverflow: "ellipsis",
	maxWidth: "100%",
	overflow: "hidden",
	fontWeight: 500,
	whiteSpace: "nowrap",
	flex: 1,
	margin: 0,
};
var resultContainer = {
	padding: "16px 20px",
	listStyle: "none",
	fontWeight: 500,
};
var sidebarStyles = {
	left: 0,
	width: 500,
};
var fixedTopStyles = {
	top: 0,
	width: "100%",
};
var quickMenuStyles = {
	width: 500,
};
function getLayoutBaseStyles(layoutOption, theme) {
	switch (layoutOption) {
		case "Sidebar":
			return {
				...sidebarStyles,
				width: theme.width,
			};
		case "FixedTop":
			return fixedTopStyles;
		case "QuickMenu":
			return {
				...quickMenuStyles,
				width: theme.width,
			};
	}
}
var SearchInputClearButtonType;
(function (SearchInputClearButtonType2) {
	SearchInputClearButtonType2["Icon"] = "icon";
	SearchInputClearButtonType2["Text"] = "text";
	SearchInputClearButtonType2["None"] = "none";
})(SearchInputClearButtonType || (SearchInputClearButtonType = {}));
var SearchInputDividerType;
(function (SearchInputDividerType2) {
	SearchInputDividerType2["None"] = "none";
	SearchInputDividerType2["FullWidth"] = "fullWidth";
	SearchInputDividerType2["Contained"] = "contained";
})(SearchInputDividerType || (SearchInputDividerType = {}));
var SearchResultTitleType;
(function (SearchResultTitleType2) {
	SearchResultTitleType2["H1"] = "h1";
	SearchResultTitleType2["Title"] = "title";
})(SearchResultTitleType || (SearchResultTitleType = {}));
var SearchResultSubtitleType;
(function (SearchResultSubtitleType2) {
	SearchResultSubtitleType2["Description"] = "description";
	SearchResultSubtitleType2["Path"] = "path";
})(SearchResultSubtitleType || (SearchResultSubtitleType = {}));
var SearchResultItemType;
(function (SearchResultItemType2) {
	SearchResultItemType2["FullWidth"] = "fullWidth";
	SearchResultItemType2["Contained"] = "contained";
})(SearchResultItemType || (SearchResultItemType = {}));
var SearchLayoutType;
(function (SearchLayoutType2) {
	SearchLayoutType2["Sidebar"] = "Sidebar";
	SearchLayoutType2["FixedTop"] = "FixedTop";
	SearchLayoutType2["QuickMenu"] = "QuickMenu";
})(SearchLayoutType || (SearchLayoutType = {}));
var SearchEntryType;
(function (SearchEntryType2) {
	SearchEntryType2["Icon"] = "icon";
	SearchEntryType2["Text"] = "text";
})(SearchEntryType || (SearchEntryType = {}));
var SearchIconType;
(function (SearchIconType2) {
	SearchIconType2["Default"] = "default";
	SearchIconType2["Custom"] = "custom";
})(SearchIconType || (SearchIconType = {}));
function SearchModal(props) {
	const {
		layoutType,
		theme,
		urlScope,
		inputOptions,
		backdropOptions,
		modalOptions,
		resultOptions,
		onDismiss,
	} = props;
	const { activeLocale } = useLocaleInfo2();
	const localeId =
		activeLocale === null || activeLocale === void 0 ? void 0 : activeLocale.id;
	const localeSlug =
		activeLocale === null || activeLocale === void 0
			? void 0
			: activeLocale.slug;
	const input = useRef2();
	const selectedResultRow = useRef2();
	const scrollView = useRef2();
	const [selected, setSelected] = useState2({
		index: 0,
		scroll: true,
	});
	const prevMousePositionRef = useRef2(null);
	const [isKeyboardNavigationDisabled, setIsKeyboardNavigationDisabled] =
		useState2(Browser.isTouch);
	const [query, setQuery] = useState2("");
	const deferredQuery = useDeferredValue(query);
	const { results, status } = useSearch(deferredQuery, {
		minimumScore: 0,
		urlScope,
		titleType: resultOptions.titleType,
	});
	const selectedResult = results[selected.index];
	const verticalSpacing = Math.floor(
		theme ? theme.horizontalSpacing * VERTICAL_SPACING_MULTIPLIER : 0,
	);
	useEffect2(() => {
		setSelected({
			index: 0,
			scroll: true,
		});
	}, [deferredQuery]);
	const handleResultRowPointerDown = useCallback2((event, index) => {
		if (event.pointerType !== "touch") return;
		setIsKeyboardNavigationDisabled(true);
		setSelected({
			index,
			scroll: false,
		});
	}, []);
	const handleResultRowMouseMove = useCallback2((event, index) => {
		setSelected((previousSelected) => {
			if (previousSelected.index === index) {
				return previousSelected;
			}
			return {
				index,
				scroll: false,
			};
		});
	}, []);
	const router = useRouter();
	const navigateTo = useCallback2(
		async (url) => {
			if (status === "no-meta-tag-found") {
				return;
			}
			try {
				var _router_getRoute,
					_route_page_preload,
					_route_page,
					_router_navigate;
				const { routeId, pathVariables } = inferInitialRouteFromPath(
					router.routes,
					url,
				);
				const route =
					(_router_getRoute = router.getRoute) === null ||
					_router_getRoute === void 0
						? void 0
						: _router_getRoute.call(router, routeId);
				onDismiss();
				await (route === null || route === void 0
					? void 0
					: (_route_page = route.page) === null || _route_page === void 0
						? void 0
						: (_route_page_preload = _route_page.preload) === null ||
								_route_page_preload === void 0
							? void 0
							: _route_page_preload.call(_route_page));
				(_router_navigate = router.navigate) === null ||
				_router_navigate === void 0
					? void 0
					: _router_navigate.call(router, routeId, null, pathVariables, false);
			} catch (error) {
				window.location.href = url;
			}
		},
		[status],
	);
	const handleKeyDown = (event) => {
		const maxIndex = results.length - 1;
		switch (event.code) {
			case "ArrowUp":
				event.preventDefault();
				if (isKeyboardNavigationDisabled) {
					setIsKeyboardNavigationDisabled(false);
					break;
				}
				setSelected((previousSelected) => ({
					index: clamp2(0, maxIndex, previousSelected.index - 1),
					scroll: true,
				}));
				break;
			case "ArrowDown":
				event.preventDefault();
				if (isKeyboardNavigationDisabled) {
					setIsKeyboardNavigationDisabled(false);
					break;
				}
				setSelected((previousSelected) => ({
					index: clamp2(0, maxIndex, previousSelected.index + 1),
					scroll: true,
				}));
				break;
			case "Escape":
				break;
			case "Enter":
				if (selectedResult) {
					navigateTo(selectedResult.url);
				}
				break;
			default:
				event.stopPropagation();
		}
	};
	const showNoResults =
		results.length === 0 && deferredQuery.length > 1 && status !== "loading";
	const showDivider = Boolean(
		((deferredQuery.length > 0 && results.length > 0) || showNoResults) &&
			status !== "loading" &&
			props.inputOptions &&
			props.inputOptions.dividerType !== "none",
	);
	const isItemContained = Boolean(
		props.resultOptions && props.resultOptions.itemType === "contained",
	);
	const spacing = isItemContained ? theme.spacing : 10;
	const listPaddingTop =
		showDivider && isItemContained ? spacing + theme.gapBetweenResults * 2 : 0;
	useEffect2(() => {
		if (!selected.scroll) return;
		const element = selectedResultRow.current;
		if (!element) return;
		scrollIntoView(element, scrollView.current, {
			offsetTop: showDivider && isItemContained ? listPaddingTop : 0,
			offsetBottom: isItemContained ? spacing : 0,
		});
	}, [selected]);
	return (
		<LayoutContainer
			layoutType={layoutType}
			modalOptions={modalOptions}
			theme={theme}
			onKeyDown={handleKeyDown}
			onDismiss={onDismiss}
		>
			<ModalContainer
				layoutType={layoutType}
				theme={theme}
				heightIsStatic={modalOptions.heightIsStatic}
				heightTransition={modalOptions.heightTransition}
				heightDeps={[results.length, showNoResults]}
			>
				<Input
					autofocus={true}
					ref={input}
					onChange={setQuery}
					value={query}
					theme={theme}
					status={status}
					iconType={inputOptions.iconOptions.iconType}
					placeholder={inputOptions.placeholderOptions.placeholderText}
					clearButtonType={inputOptions ? inputOptions.clearButtonType : void 0}
					clearButtonText={inputOptions.clearButtonText}
				/>
				{showDivider && (
					<Divider theme={theme} type={inputOptions.dividerType} />
				)}
				<ScrollView ref={scrollView} theme={theme}>
					<ul
						aria-live={"polite"}
						style={{
							display: "flex",
							flexDirection: "column",
							width: `calc(100% - ${theme.scrollBarWidth}px)`,
							padding: 0,
							paddingTop: listPaddingTop,
							paddingBottom: results.length && isItemContained ? spacing : 0,
							gap: theme.gapBetweenResults,
							margin: 0,
						}}
					>
						{results.map((result, index) => {
							const isSelected = index === selected.index;
							return (
								<ResultRow
									ref={isSelected ? selectedResultRow : null}
									index={index}
									result={result}
									prevMousePositionRef={prevMousePositionRef}
									selected={!isKeyboardNavigationDisabled && isSelected}
									type={props.resultOptions.itemType}
									subtitleType={
										props.resultOptions.subtitleOptions.subtitleType
									}
									theme={theme}
									localeSlug={localeSlug}
									onMouseMove={handleResultRowMouseMove}
									onPointerDown={handleResultRowPointerDown}
									onNavigateTo={navigateTo}
								/>
							);
						})}
						{showNoResults && (
							<li
								style={{
									paddingTop: verticalSpacing - listPaddingTop,
									paddingBottom: verticalSpacing,
									lineHeight: "2em",
									paddingLeft: theme && theme.horizontalSpacing,
									paddingRight: theme && theme.horizontalSpacing,
									height: "Sidebar" ? "100%" : "auto",
								}}
							>
								<h3
									style={{
										...resultTitle,
										textAlign: "center",
										lineHeight: `calc(${theme.inputFontSize} * 2)`,
										color: theme.subtitleColor,
										...theme.titleFont,
									}}
								>
									{"No results"}
								</h3>
							</li>
						)}
					</ul>
				</ScrollView>
			</ModalContainer>
			<StatusMessage status={status} layoutType={layoutType} theme={theme} />
		</LayoutContainer>
	);
}

// /:https://framerusercontent.com/modules/hqEf5wXaAewP8VPuaZ98/5A0QGVeEr2cwheQpIuEG/useViewportSizeState.js
import { useEffect as useEffect3, useState as useState3 } from "react";
function getViewportSize() {
	if (typeof window === "undefined") {
		return {
			width: 0,
			height: 0,
		};
	}
	return {
		width: window.innerWidth,
		height: window.innerHeight,
	};
}
function useViewportSizeState(getState) {
	const [state, setState] = useState3(() => getState(getViewportSize()));
	useEffect3(() => {
		const handleWindowResize = () => setState(getState(getViewportSize()));
		window.addEventListener("resize", handleWindowResize);
		return () => {
			window.removeEventListener("resize", handleWindowResize);
		};
	}, []);
	return state;
}

// /:https://framerusercontent.com/modules/6wAE2eMb2Tl3zrU7u4UL/HPzg2Uk7mwtBmDzvGbWF/Search.js
var EntryPointOptions;
(function (EntryPointOptions2) {
	EntryPointOptions2["icon"] = "Icon";
	EntryPointOptions2["input"] = "Input";
})(EntryPointOptions || (EntryPointOptions = {}));
function buildShadow(shadowProperty, fallback = "none") {
	if (!shadowProperty) return fallback;
	const { x, y, blur, color, spread } = shadowProperty;
	return `${x}px ${y}px ${blur}px ${spread}px ${color}`;
}
var Overlay = /* @__PURE__ */ forwardRef2(function Overlay2(props, ref) {
	const { layoutType, theme, onDismiss } = props;
	useEffect4(() => {
		const handleKeyDown = (event) => {
			if (event.code === "Escape") {
				event.stopPropagation();
				onDismiss();
			}
		};
		const handlePointerDown = (event) => {
			if (event.pointerType !== "touch") return;
			const isWithinSearchHeader = Boolean(
				event.target instanceof Element &&
					event.target.closest("[role=search]"),
			);
			if (isWithinSearchHeader) return;
			if (document.activeElement instanceof HTMLInputElement) {
				document.activeElement.blur();
			}
		};
		window.addEventListener("keydown", handleKeyDown);
		window.addEventListener("pointerdown", handlePointerDown, {
			capture: true,
		});
		document.body.classList.add(bodyOverflowHidden);
		return () => {
			window.removeEventListener("keydown", handleKeyDown);
			window.removeEventListener("pointerdown", handlePointerDown, {
				capture: true,
			});
			document.body.classList.remove(bodyOverflowHidden);
		};
	}, []);
	return /* @__PURE__ */ createPortal(
		<div
			ref={ref}
			className={"__framer-search-modal-container"}
			role={"presentation"}
			style={{
				...backdropStyles,
				zIndex: props.backdropOptions.zIndex,
				justifyContent:
					layoutType === SearchLayoutType.Sidebar ? "flex-start" : "center",
			}}
			onClick={onDismiss}
		>
			<motion3.div
				role={"presentation"}
				initial={{
					opacity: 0,
				}}
				animate={{
					opacity: 1,
				}}
				exit={{
					opacity: 0,
					transition: {
						duration: 0,
					},
				}}
				transition={theme.overlayTransition}
				style={{
					top: 0,
					left: 0,
					right: 0,
					bottom: 0,
					width: "100%",
					height: "100%",
					boxSizing: "border-box",
					position: "absolute",
					touchAction: "none",
					backgroundColor: props.backdropOptions.backgroundColor,
				}}
			/>
			<SearchModal
				urlScope={props.urlScope}
				layoutType={layoutType}
				inputOptions={props.inputOptions}
				resultOptions={props.resultOptions}
				modalOptions={props.modalOptions}
				backdropOptions={props.backdropOptions}
				theme={props.theme}
				onDismiss={onDismiss}
			/>
		</div>,
		document.body,
	);
});
var backdropStyles = {
	width: "100%",
	boxSizing: "border-box",
	willChange: "transform",
	position: "fixed",
	display: "flex",
	alignItems: "flex-start",
	top: 0,
	left: 0,
	right: 0,
	bottom: 0,
};
var containerStyle = {
	height: "100%",
	display: "flex",
	borderRadius: 10,
	cursor: "inherit",
	overflow: "hidden",
};
var bodyOverflowHidden = "__framer-overflow-hidden";
var EntryPoint = withCSS(
	function EntryPoint2(props) {
		var _props_inputOptions_inputFont,
			_props_inputOptions,
			_props_resultOptions,
			_props_resultOptions_subtitleOptions,
			_props_inputOptions1;
		const overlay = useRef3(null);
		const [isOpen, setIsOpen] = useState4(false);
		const [isOverLimit, setIsOverLimit] = useState4(false);
		const [isSafariTouchDevice, setIsSafariTouchDevice] = useState4(false);
		const [isOnCanvas] = useState4(
			() => RenderTarget.current() === RenderTarget.canvas,
		);
		useEffect4(() => {
			setIsOverLimit(checkIfOverLimit());
			setIsSafariTouchDevice(Browser.isSafari() && Browser.isTouch());
		}, []);
		const baseInputFontSize = (
			(_props_inputOptions = props.inputOptions) === null ||
			_props_inputOptions === void 0
				? void 0
				: (_props_inputOptions_inputFont = _props_inputOptions.inputFont) ===
							null || _props_inputOptions_inputFont === void 0
					? void 0
					: _props_inputOptions_inputFont.fontSize
		)
			? props.inputOptions.inputFont.fontSize
			: "16px";
		const inputFontSize = isSafariTouchDevice
			? `max(16px, ${baseInputFontSize})`
			: baseInputFontSize;
		const layoutType = useViewportSizeState((size) => {
			if (size.width < props.modalOptions.width + 10) {
				return SearchLayoutType.FixedTop;
			}
			return props.modalOptions.layoutType || props.layoutType;
		});
		const theme = {
			subtitleColor: props.resultOptions.subtitleOptions.subtitleColor,
			backgroundColor: props.modalOptions.backgroundColor,
			foregroundColor: props.resultOptions.titleColor,
			placeholderColor: props.inputOptions.placeholderOptions.placeholderColor,
			titleFont:
				((_props_resultOptions = props.resultOptions) === null ||
				_props_resultOptions === void 0
					? void 0
					: _props_resultOptions.titleFont) &&
				!isEmptyObject(props.resultOptions.titleFont)
					? props.resultOptions.titleFont
					: {
							fontSize: 14,
							fontFamily: DEFAULT_FONT_FAMILY,
							fontWeight: 500,
						},
			subtitleFont:
				((_props_resultOptions_subtitleOptions =
					props.resultOptions.subtitleOptions) === null ||
				_props_resultOptions_subtitleOptions === void 0
					? void 0
					: _props_resultOptions_subtitleOptions.subtitleFont) &&
				!isEmptyObject(props.resultOptions.subtitleOptions.subtitleFont)
					? props.resultOptions.subtitleOptions.subtitleFont
					: {
							fontSize: 12,
							fontFamily: DEFAULT_FONT_FAMILY,
							fontWeight: 500,
						},
			inputFont:
				((_props_inputOptions1 = props.inputOptions) === null ||
				_props_inputOptions1 === void 0
					? void 0
					: _props_inputOptions1.inputFont) &&
				!isEmptyObject(props.inputOptions.inputFont)
					? props.inputOptions.inputFont
					: {
							fontSize: 16,
							fontFamily: DEFAULT_FONT_FAMILY,
							fontWeight: 500,
						},
			// Keep separate so we can more easily override
			inputFontSize,
			width: props.modalOptions.width,
			offsetTop: props.modalOptions.top,
			borderRadius: props.modalOptions.borderRadius,
			shadow: buildShadow(props.modalOptions.shadow),
			entryIconColor: props.iconColor,
			entryIconSize: props.iconSize,
			entryIconImage: props.iconImage,
			inputIconSize: props.inputOptions.iconOptions.iconSize,
			inputIconColor: props.inputOptions.iconOptions.iconColor,
			inputIconImage: props.inputOptions.iconOptions.iconImage,
			gapBetweenStatusAndSearch: 16,
			gapBetweenResults: 1,
			scrollBarWidth: 20,
			margin: 10,
			spacing: 8,
			zIndex: props.backdropOptions.zIndex,
			horizontalSpacing: 20,
			overlayTransition: props.backdropOptions.transition,
		};
		const handleClick = (event) => {
			event.preventDefault();
			event.stopPropagation();
			if (isOverLimit) return;
			setIsOpen(true);
		};
		return (
			<div
				style={{
					...containerStyle,
					...props.style,
					pointerEvents: isOverLimit ? "none" : "auto",
					opacity: isOverLimit ? 0.4 : 1,
				}}
			>
				<button
					aria-label={"Search Icon"}
					style={{
						width: "100%",
						height: "100%",
						display: "flex",
						alignItems: "center",
						justifyContent: "center",
						background: "none",
						cursor: "inherit",
						color: "inherit",
						border: "none",
						outline: "inherit",
						padding: 0,
					}}
					onClick={handleClick}
				>
					{props.iconType === SearchIconType.Custom && theme.entryIconImage ? (
						<img
							alt={"icon entry point for Site Search"}
							src={theme.entryIconImage.src}
							width={theme.entryIconSize}
							height={theme.entryIconSize}
						/>
					) : (
						<SearchIcon
							color={theme.entryIconColor}
							width={theme.entryIconSize}
							height={theme.entryIconSize}
						/>
					)}
				</button>
				<AnimatePresence>
					{isOpen && !isOnCanvas && (
						<Overlay
							ref={overlay}
							layoutType={layoutType}
							urlScope={props.urlScope}
							inputOptions={props.inputOptions}
							resultOptions={props.resultOptions}
							backdropOptions={props.backdropOptions}
							modalOptions={props.modalOptions}
							theme={theme}
							onDismiss={() => setIsOpen(false)}
						/>
					)}
				</AnimatePresence>
			</div>
		);
	},
	[
		// Prevent scrolling on iOS Safari when Input is focused.
		// From: https://gist.github.com/kiding/72721a0553fa93198ae2bb6eefaa3299
		`
        @keyframes __framer-blink-input {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }

        .__framer-search-modal-container input:focus {
            animation: __framer-blink-input 0.01s;
        }
        `,
		// Allow styling of input placeholder
		`
         .__framer-search-modal-container input::placeholder, 
         .__framer-search-modal-container input::-webkit-input-placeholder { 
            color: var(--framer-search-placeholder-color, #999999);
            opacity: 1;
        }
        `,
		// Allow fallback to 100vh when dvh unit is not supported.
		`
        .__framer-search-modal-container {
            height: 100vh;
            height: 100dvh;
        }
        .__framer-search-modal-container .__framer-max-height-80dvh {
            max-height: 80vh;
            max-height: 80dvh;
        }
        `,
		`
        body.${bodyOverflowHidden} {
            overflow: hidden;
        }`,
		// Increase hit target
		`
        button.__framer-search-clear-button {
            position: relative;
        }
        button.__framer-search-clear-button::after {
            content: "";
            position: absolute;
            top: -10px;
            right: -10px;
            bottom: -10px;
            left: -10px;
        }`,
	],
);
var stdin_default = EntryPoint;
addPropertyControls(EntryPoint, {
	urlScope: {
		title: "Scope",
		// @ts-ignore - Internal
		type: ControlType.PageScope,
	},
	// entryType: {
	//     title: "Type",
	//     type: ControlType.Enum,
	//     options: Object.values(SearchEntryType),
	//     optionTitles: Object.values(SearchEntryType).map(titleCase),
	//     displaySegmentedControl: true,
	// },
	iconType: {
		title: "Icon",
		type: ControlType.Enum,
		options: Object.values(SearchIconType),
		optionTitles: Object.values(SearchIconType).map(titleCase),
		displaySegmentedControl: true,
	},
	iconColor: {
		title: "Color",
		type: ControlType.Color,
		defaultValue: "#333",
		hidden: (props) => props.iconType === SearchIconType.Custom,
	},
	iconImage: {
		title: "File",
		type: ControlType.ResponsiveImage,
		allowedFileTypes: ["jpg", "png", "svg"],
		hidden: (props) => props.iconType === SearchIconType.Default,
	},
	iconSize: {
		title: "Size",
		type: ControlType.Number,
		displayStepper: true,
		defaultValue: 24,
	},
	inputOptions: {
		title: "Input",
		type: ControlType.Object,
		buttonTitle: "Icon, Styles",
		controls: {
			iconOptions: {
				title: "Icon",
				type: ControlType.Object,
				buttonTitle: "Color, Size",
				controls: {
					iconType: {
						title: "Icon",
						type: ControlType.Enum,
						options: Object.values(SearchIconType),
						optionTitles: Object.values(SearchIconType).map(titleCase),
						displaySegmentedControl: true,
					},
					iconColor: {
						title: "Color",
						type: ControlType.Color,
						defaultValue: "rgba(0, 0, 0, 0.45)",
						hidden: ({ iconType }) => {
							return iconType === SearchIconType.Custom;
						},
					},
					iconImage: {
						title: "File",
						type: ControlType.ResponsiveImage,
						allowedFileTypes: ["jpg", "png", "svg"],
						hidden: ({ iconType }) => iconType === SearchIconType.Default,
					},
					iconSize: {
						title: "Icon Size",
						type: ControlType.Number,
						displayStepper: true,
						defaultValue: 18,
						min: 0,
						max: 100,
					},
				},
			},
			inputFont: {
				title: "Font",
				// @ts-ignore Internal
				type: ControlType.Font,
				displayFontSize: true,
			},
			textColor: {
				title: "Color",
				type: ControlType.Color,
				defaultValue: "#333",
			},
			placeholderOptions: {
				title: "Placeholder",
				type: ControlType.Object,
				buttonTitle: "Color, Text",
				controls: {
					placeholderText: {
						title: "Text",
						type: ControlType.String,
						defaultValue: "Search...",
					},
					placeholderColor: {
						title: "Color",
						type: ControlType.Color,
						defaultValue: "rgba(0,0,0,0.4)",
					},
				},
			},
			dividerType: {
				title: "Divider",
				type: ControlType.Enum,
				options: Object.values(SearchInputDividerType),
				optionTitles: Object.keys(SearchInputDividerType).map(titleCase),
				defaultValue: SearchInputDividerType.FullWidth,
			},
			clearButtonType: {
				title: "Clear Type",
				type: ControlType.Enum,
				options: Object.values(SearchInputClearButtonType),
				optionTitles: Object.keys(SearchInputClearButtonType).map(titleCase),
				defaultValue: SearchInputClearButtonType.Icon,
			},
			clearButtonText: {
				title: "Clear Text",
				type: ControlType.String,
				defaultValue: "Clear",
				hidden: (props) =>
					props.clearButtonType !== SearchInputClearButtonType.Text,
			},
		},
	},
	modalOptions: {
		title: "Modal",
		buttonTitle: "Layout, Width",
		type: ControlType.Object,
		controls: {
			layoutType: {
				title: "Layout",
				type: ControlType.Enum,
				options: Object.keys(SearchLayoutType),
				optionTitles: Object.values(SearchLayoutType).map(titleCase),
				defaultValue: SearchLayoutType.QuickMenu,
			},
			width: {
				title: "Width",
				type: ControlType.Number,
				defaultValue: 500,
				min: 200,
				max: 1e3,
				displayStepper: true,
				step: 5,
				hidden: (props) => props.layoutType === SearchLayoutType.FixedTop,
			},
			top: {
				title: "Top",
				type: ControlType.Number,
				defaultValue: 0,
				min: 0,
				max: 1e3,
				displayStepper: true,
				hidden: (props) => props.layoutType !== SearchLayoutType.FixedTop,
			},
			heightIsStatic: {
				title: "Height",
				type: ControlType.Boolean,
				enabledTitle: "Instant",
				disabledTitle: "Animate",
				hidden: ({ layoutType }) => layoutType !== SearchLayoutType.QuickMenu,
			},
			heightTransition: {
				title: "Type",
				type: ControlType.Transition,
				defaultValue: {
					type: "spring",
					stiffness: 800,
					damping: 60,
				},
				hidden: ({ heightIsStatic, layoutType }) =>
					layoutType !== SearchLayoutType.QuickMenu || heightIsStatic,
			},
			borderRadius: {
				title: "Radius",
				type: ControlType.Number,
				defaultValue: 16,
				displayStepper: true,
				min: 0,
				hidden: ({ layoutType }) => layoutType !== SearchLayoutType.QuickMenu,
			},
			shadow: {
				buttonTitle: "Options",
				type: ControlType.Object,
				defaultValue: {
					x: 0,
					y: 20,
					blur: 40,
					spread: 0,
					color: "rgba(0,0,0,0.2)",
				},
				controls: {
					color: {
						type: ControlType.Color,
						defaultValue: "rgba(0,0,0,0.2)",
					},
					x: {
						type: ControlType.Number,
						defaultValue: 0,
					},
					y: {
						type: ControlType.Number,
						defaultValue: 20,
					},
					blur: {
						type: ControlType.Number,
						defaultValue: 40,
					},
					spread: {
						type: ControlType.Number,
						defaultValue: 0,
					},
				},
			},
			backgroundColor: {
				title: "Background",
				type: ControlType.Color,
				defaultValue: "#FFF",
			},
			[animationKeyFromLayout(SearchLayoutType.QuickMenu)]: {
				title: "Animation",
				type: ControlType.Object,
				icon: "effect",
				hidden: ({ layoutType }) => layoutType !== SearchLayoutType.QuickMenu,
				optional: true,
				buttonTitle: "Options",
				controls: {
					opacity: {
						type: ControlType.Number,
						defaultValue: 0.5,
						step: 0.1,
						min: 0,
						max: 1,
					},
					scale: {
						type: ControlType.Number,
						defaultValue: 0.75,
						step: 0.1,
						min: 0,
						max: 2,
					},
					// rotate: {
					//     type: ControlType.Number,
					//     defaultValue: 0,
					//     min: -360,
					//     max: 360,
					// },
					x: {
						type: ControlType.Number,
						defaultValue: 0,
						min: -500,
						max: 500,
					},
					y: {
						type: ControlType.Number,
						defaultValue: 0,
						min: -500,
						max: 500,
					},
					transition: {
						type: ControlType.Transition,
					},
				},
			},
			[animationKeyFromLayout(SearchLayoutType.FixedTop)]: {
				title: "Animation",
				type: ControlType.Object,
				icon: "effect",
				buttonTitle: "Options",
				hidden: ({ layoutType }) => layoutType !== SearchLayoutType.FixedTop,
				optional: true,
				controls: {
					opacity: {
						type: ControlType.Number,
						defaultValue: 0.8,
						step: 0.1,
						min: 0,
						max: 1,
					},
					y: {
						type: ControlType.Number,
						defaultValue: 0,
						min: -100,
						max: 100,
					},
					transition: {
						type: ControlType.Transition,
					},
				},
			},
			[animationKeyFromLayout(SearchLayoutType.Sidebar)]: {
				title: "Animation",
				type: ControlType.Object,
				icon: "effect",
				buttonTitle: "Options",
				hidden: ({ layoutType }) => layoutType !== SearchLayoutType.Sidebar,
				optional: true,
				controls: {
					opacity: {
						type: ControlType.Number,
						defaultValue: 0.8,
						step: 0.1,
						min: 0,
						max: 1,
					},
					x: {
						type: ControlType.Number,
						defaultValue: 0,
						min: -1e3,
						max: 1e3,
					},
					transition: {
						type: ControlType.Transition,
					},
				},
			},
		},
	},
	resultOptions: {
		title: "Results",
		buttonTitle: "Fonts, Style",
		type: ControlType.Object,
		defaultValue: {},
		// description:
		//     "Learn more about how to use Site Search [here](https://framer.com/learn/site-search)",
		controls: {
			itemType: {
				title: "Style",
				type: ControlType.Enum,
				options: Object.values(SearchResultItemType),
				optionTitles: Object.keys(SearchResultItemType).map(titleCase),
				defaultValue: SearchResultItemType.FullWidth,
			},
			titleFont: {
				title: "Title",
				// @ts-ignore - Internal
				type: ControlType.Font,
				defaultValue: {
					fontSize: 15,
				},
				displayFontSize: true,
			},
			titleColor: {
				title: "Color",
				type: ControlType.Color,
				defaultValue: "#333",
			},
			titleType: {
				title: "Content",
				type: ControlType.Enum,
				options: Object.values(SearchResultTitleType),
				optionTitles: Object.keys(SearchResultTitleType).map(titleCase),
				defaultValue: SearchResultTitleType.H1,
				displaySegmentedControl: true,
			},
			subtitleOptions: {
				type: ControlType.Object,
				title: "Subtitle",
				buttonTitle: "Font, Content",
				controls: {
					subtitleFont: {
						title: "Font",
						// @ts-ignore - Internal
						type: ControlType.Font,
						defaultValue: {
							fontSize: 13,
						},
						displayFontSize: true,
					},
					subtitleColor: {
						title: "Color",
						type: ControlType.Color,
						defaultValue: "rgba(0, 0, 0, 0.4)",
					},
					subtitleType: {
						title: "Content",
						type: ControlType.Enum,
						options: Object.values(SearchResultSubtitleType),
						optionTitles: Object.keys(SearchResultSubtitleType).map(titleCase),
						defaultValue: SearchResultSubtitleType.Path,
					},
				},
			},
		},
	},
	backdropOptions: {
		title: "Backdrop",
		type: ControlType.Object,
		buttonTitle: "Color, Z Index",
		controls: {
			backgroundColor: {
				title: "Color",
				type: ControlType.Color,
				defaultValue: "rgba(0, 0, 0, 0.8)",
			},
			zIndex: {
				title: "Z Index",
				type: ControlType.Number,
				defaultValue: 10,
				displayStepper: true,
				min: 0,
				max: 10,
			},
			transition: {
				type: ControlType.Transition,
			},
		},
	},
});
EntryPoint.displayName = "Search";

// /:https://framerusercontent.com/modules/9UAJj0iki6gynMc1A5PF/lPfa8uJucm8GreYWEGAr/wvuAi9wiC.js
var SearchFonts = getFonts(stdin_default);
var cycleOrder = ["jsVKEKG4s", "lBkI6MWTM"];
var serializationHash = "framer-ORLXf";
var variantClassNames = {
	jsVKEKG4s: "framer-v-1rtq0nx",
	lBkI6MWTM: "framer-v-ldyh1u",
};
function addPropertyOverrides(overrides, ...variants) {
	const nextOverrides = {};
	variants?.forEach(
		(variant) => variant && Object.assign(nextOverrides, overrides[variant]),
	);
	return nextOverrides;
}
var transition1 = {
	damping: 60,
	delay: 0,
	mass: 1,
	stiffness: 500,
	type: "spring",
};
var addImageAlt = (image, alt) => {
	if (!image || typeof image !== "object") {
		return;
	}
	return {
		...image,
		alt,
	};
};
var Transition = ({ value, children }) => {
	const config = React2.useContext(MotionConfigContext);
	const transition = value ?? config.transition;
	const contextValue = React2.useMemo(
		() => ({
			...config,
			transition,
		}),
		[JSON.stringify(transition)],
	);
	return (
		<MotionConfigContext.Provider value={contextValue}>
			{children}
		</MotionConfigContext.Provider>
	);
};
var Variants = motion4(React2.Fragment);
var humanReadableVariantMap = {
	Desktop: "jsVKEKG4s",
	Mobile: "lBkI6MWTM",
};
var getProps = ({ height, id, width, ...props }) => {
	return {
		...props,
		variant:
			humanReadableVariantMap[props.variant] ?? props.variant ?? "jsVKEKG4s",
	};
};
var createLayoutDependency = (props, variants) => {
	if (props.layoutDependency)
		return variants.join("-") + props.layoutDependency;
	return variants.join("-");
};
var Component = /* @__PURE__ */ React2.forwardRef(function (props, ref) {
	const { activeLocale, setLocale } = useLocaleInfo3();
	const {
		style,
		className: className2,
		layoutId,
		variant,
		...restProps
	} = getProps(props);
	const {
		baseVariant,
		classNames,
		clearLoadingGesture,
		gestureHandlers,
		gestureVariant,
		isLoading,
		setGestureState,
		setVariant,
		variants,
	} = useVariantState({
		cycleOrder,
		defaultVariant: "jsVKEKG4s",
		variant,
		variantClassNames,
	});
	const layoutDependency = createLayoutDependency(props, variants);
	const ref1 = React2.useRef(null);
	const defaultLayoutId = React2.useId();
	const sharedStyleClassNames = [className];
	const componentViewport = useComponentViewport();
	return (
		<LayoutGroup id={layoutId ?? defaultLayoutId}>
			<Variants animate={variants} initial={false}>
				<Transition value={transition1}>
					<motion4.div
						{...restProps}
						{...gestureHandlers}
						className={cx(
							serializationHash,
							...sharedStyleClassNames,
							"framer-1rtq0nx",
							className2,
							classNames,
						)}
						data-border={true}
						data-framer-name={"Desktop"}
						layoutDependency={layoutDependency}
						layoutId={"jsVKEKG4s"}
						ref={ref ?? ref1}
						style={{
							"--border-bottom-width": "1px",
							"--border-color":
								"var(--token-1691cb44-c002-4542-9545-8a0801f91af2, rgb(231, 231, 231))",
							"--border-left-width": "0px",
							"--border-right-width": "0px",
							"--border-style": "solid",
							"--border-top-width": "0px",
							backgroundColor:
								"var(--token-f1edbbf0-4dde-4043-88fc-e447b2e4f208, rgb(255, 255, 255))",
							...style,
						}}
						{...addPropertyOverrides(
							{
								lBkI6MWTM: {
									"data-framer-name": "Mobile",
								},
							},
							baseVariant,
							gestureVariant,
						)}
					>
						<motion4.div
							className={"framer-14gp762"}
							data-framer-name={"Search Container"}
							layoutDependency={layoutDependency}
							layoutId={"AOFl7NI65"}
						>
							<ComponentViewportProvider>
								<motion4.div
									className={"framer-1s197uu-container"}
									layoutDependency={layoutDependency}
									layoutId={"G38UBLMGf-container"}
									style={{
										opacity: 0,
									}}
								>
									{_jsx4(stdin_default, {
										backdropOptions: {
											backgroundColor: "rgba(0, 0, 0, 0.3)",
											transition: {
												damping: 60,
												delay: 0,
												duration: 0.3,
												ease: [0.44, 0, 0.56, 1],
												mass: 1,
												stiffness: 500,
												type: "spring",
											},
											zIndex: 10,
										},
										height: "100%",
										iconColor:
											"var(--token-0903d63a-94ee-49f4-896e-eb837e1f22c9, rgb(160, 160, 160))",
										iconImage: addImageAlt(
											{
												src: "https://framerusercontent.com/images/LcSrauRN6S5dbcfiUyHSBISkE.svg",
											},
											"",
										),
										iconSize: 20,
										iconType: "custom",
										id: "G38UBLMGf",
										inputOptions: {
											clearButtonText: "Clear",
											clearButtonType: "icon",
											dividerType: "fullWidth",
											iconOptions: {
												iconColor:
													"var(--token-0903d63a-94ee-49f4-896e-eb837e1f22c9, rgb(160, 160, 160))",
												iconImage: addImageAlt(
													{
														src: "https://framerusercontent.com/images/LcSrauRN6S5dbcfiUyHSBISkE.svg",
													},
													"",
												),
												iconSize: 20,
												iconType: "custom",
											},
											inputFont: {
												fontFamily:
													'"General Sans", "General Sans Placeholder", sans-serif',
												fontSize: "20px",
												fontStyle: "normal",
												fontWeight: 500,
											},
											placeholderOptions: {
												placeholderColor:
													"var(--token-0903d63a-94ee-49f4-896e-eb837e1f22c9, rgb(160, 160, 160))",
												placeholderText: "Search Docs...",
											},
											textColor:
												"var(--token-6fff741a-90b6-438e-9423-1f7c07944681, rgb(17, 17, 17))",
										},
										layoutId: "G38UBLMGf",
										modalOptions: {
											backgroundColor:
												"var(--token-74b02f5b-961b-49eb-8e13-4477bd831f3e, rgb(250, 250, 251))",
											borderRadius: 18,
											heightIsStatic: false,
											heightTransition: {
												damping: 60,
												stiffness: 800,
												type: "spring",
											},
											layoutType: "QuickMenu",
											shadow: {
												blur: 40,
												color: "rgba(0, 0, 0, 0.2)",
												spread: 0,
												x: 0,
												y: 20,
											},
											top: 0,
											width: 500,
										},
										resultOptions: {
											itemType: "contained",
											subtitleOptions: {
												subtitleColor:
													"var(--token-95cb0a67-053e-4ab2-a5d0-7294f60d31fe, rgb(136, 136, 138))",
												subtitleFont: {
													fontFamily:
														'"General Sans", "General Sans Placeholder", sans-serif',
													fontSize: "14px",
													fontStyle: "normal",
													fontWeight: 500,
												},
												subtitleType: "description",
											},
											titleColor:
												"var(--token-6fff741a-90b6-438e-9423-1f7c07944681, rgb(17, 17, 17))",
											titleFont: {
												fontFamily:
													'"General Sans", "General Sans Placeholder", sans-serif',
												fontSize: "16px",
												fontStyle: "normal",
												fontWeight: 500,
											},
											titleType: "h1",
										},
										style: {
											height: "100%",
											width: "100%",
										},
										width: "100%",
										...addPropertyOverrides(
											{
												lBkI6MWTM: {
													backdropOptions: {
														backgroundColor: "rgba(0, 0, 0, 0.3)",
														transition: {
															damping: 60,
															delay: 0,
															duration: 0.3,
															ease: [0.44, 0, 0.56, 1],
															mass: 1,
															stiffness: 800,
															type: "spring",
														},
														zIndex: 2,
													},
													inputOptions: {
														clearButtonText: "Clear",
														clearButtonType: "icon",
														dividerType: "fullWidth",
														iconOptions: {
															iconColor:
																"var(--token-0903d63a-94ee-49f4-896e-eb837e1f22c9, rgb(160, 160, 160))",
															iconImage: addImageAlt(
																{
																	src: "https://framerusercontent.com/images/LcSrauRN6S5dbcfiUyHSBISkE.svg",
																},
																"",
															),
															iconSize: 20,
															iconType: "custom",
														},
														inputFont: {
															fontFamily:
																'"General Sans", "General Sans Placeholder", sans-serif',
															fontSize: "20px",
															fontStyle: "normal",
															fontWeight: 500,
														},
														placeholderOptions: {
															placeholderColor:
																"var(--token-0903d63a-94ee-49f4-896e-eb837e1f22c9, rgb(160, 160, 160))",
															placeholderText: "Search Docs\u2026",
														},
														textColor:
															"var(--token-6fff741a-90b6-438e-9423-1f7c07944681, rgb(17, 17, 17))",
													},
													modalOptions: {
														backgroundColor:
															"var(--token-74b02f5b-961b-49eb-8e13-4477bd831f3e, rgb(250, 250, 251))",
														borderRadius: 18,
														FixedTopAnimation: {
															opacity: 0.8,
															transition: {
																damping: 60,
																delay: 0,
																duration: 0.3,
																ease: [0.44, 0, 0.56, 1],
																mass: 1,
																stiffness: 500,
																type: false,
															},
															y: 0,
														},
														heightIsStatic: false,
														heightTransition: {
															damping: 60,
															stiffness: 800,
															type: "spring",
														},
														layoutType: "FixedTop",
														shadow: {
															blur: 40,
															color: "rgba(0, 0, 0, 0.2)",
															spread: 0,
															x: 0,
															y: 20,
														},
														top: 70,
														width: 500,
													},
												},
											},
											baseVariant,
											gestureVariant,
										),
									})}
								</motion4.div>
							</ComponentViewportProvider>
							<motion4.div
								className={"framer-19moii3"}
								data-framer-name={"Search Input"}
								layoutDependency={layoutDependency}
								layoutId={"dxNGQGLEY"}
							>
								<SVG
									className={"framer-12hme5w"}
									data-framer-name={"graphic"}
									fill={
										"var(--token-944d416b-60ec-406a-99c8-94ca89212156, rgb(169, 169, 169))"
									}
									intrinsicHeight={24}
									intrinsicWidth={24}
									layoutDependency={layoutDependency}
									layoutId={"tqZ40nGhR"}
									svg={
										'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="size-6"><path fill-rule="evenodd" d="M10.5 3.75a6.75 6.75 0 1 0 0 13.5 6.75 6.75 0 0 0 0-13.5ZM2.25 10.5a8.25 8.25 0 1 1 14.59 5.28l4.69 4.69a.75.75 0 1 1-1.06 1.06l-4.69-4.69A8.25 8.25 0 0 1 2.25 10.5Z" clip-rule="evenodd"/></svg>'
									}
									withExternalLayout={true}
								/>
								<RichText
									__fromCanvasComponent={true}
									className={"framer-8oasec"}
									fonts={["Inter"]}
									layoutDependency={layoutDependency}
									layoutId={"Vyk5gzfJN"}
									style={{
										"--extracted-r6o4lv":
											"var(--token-944d416b-60ec-406a-99c8-94ca89212156, rgba(15, 15, 15, 0.5))",
										"--framer-link-text-color": "rgb(0, 153, 255)",
										"--framer-link-text-decoration": "underline",
										"--framer-paragraph-spacing": "0px",
									}}
									verticalAlignment={"top"}
									withExternalLayout={true}
								>
									<React2.Fragment>
										<motion4.p
											className={"framer-styles-preset-17qeria"}
											data-styles-preset={"vSuRg5Prj"}
											style={{
												"--framer-text-color":
													"var(--extracted-r6o4lv, var(--token-944d416b-60ec-406a-99c8-94ca89212156, rgba(15, 15, 15, 0.5)))",
											}}
										>
											{"Search Docs\u2026"}
										</motion4.p>
									</React2.Fragment>
								</RichText>
							</motion4.div>
						</motion4.div>
					</motion4.div>
				</Transition>
			</Variants>
		</LayoutGroup>
	);
});
var css2 = [
	"@supports (aspect-ratio: 1) { body { --framer-aspect-ratio-supported: auto; } }",
	".framer-ORLXf.framer-11ewss7, .framer-ORLXf .framer-11ewss7 { display: block; }",
	".framer-ORLXf.framer-1rtq0nx { align-content: center; align-items: center; display: flex; flex-direction: row; flex-wrap: nowrap; gap: 20px; height: 72px; justify-content: flex-start; overflow: hidden; padding: 0px 24px 0px 0px; position: relative; width: 737px; }",
	".framer-ORLXf .framer-14gp762 { align-content: flex-start; align-items: flex-start; display: flex; flex: 1 0 0px; flex-direction: column; flex-wrap: nowrap; gap: 10px; height: 100%; justify-content: center; overflow: hidden; padding: 24px; position: relative; width: 1px; }",
	".framer-ORLXf .framer-1s197uu-container { bottom: 0px; cursor: text; flex: none; left: 0px; position: absolute; right: 0px; top: 0px; z-index: 1; }",
	".framer-ORLXf .framer-19moii3 { align-content: center; align-items: center; display: flex; flex: none; flex-direction: row; flex-wrap: nowrap; gap: 12px; height: 24px; justify-content: flex-start; overflow: hidden; padding: 0px; position: relative; width: 391px; }",
	".framer-ORLXf .framer-12hme5w { aspect-ratio: 1 / 1; flex: none; height: var(--framer-aspect-ratio-supported, 20px); position: relative; width: 20px; }",
	".framer-ORLXf .framer-8oasec { flex: none; height: auto; position: relative; white-space: pre; width: auto; }",
	"@supports (background: -webkit-named-image(i)) and (not (font-palette:dark)) { .framer-ORLXf.framer-1rtq0nx, .framer-ORLXf .framer-14gp762, .framer-ORLXf .framer-19moii3 { gap: 0px; } .framer-ORLXf.framer-1rtq0nx > * { margin: 0px; margin-left: calc(20px / 2); margin-right: calc(20px / 2); } .framer-ORLXf.framer-1rtq0nx > :first-child, .framer-ORLXf .framer-19moii3 > :first-child { margin-left: 0px; } .framer-ORLXf.framer-1rtq0nx > :last-child, .framer-ORLXf .framer-19moii3 > :last-child { margin-right: 0px; } .framer-ORLXf .framer-14gp762 > * { margin: 0px; margin-bottom: calc(10px / 2); margin-top: calc(10px / 2); } .framer-ORLXf .framer-14gp762 > :first-child { margin-top: 0px; } .framer-ORLXf .framer-14gp762 > :last-child { margin-bottom: 0px; } .framer-ORLXf .framer-19moii3 > * { margin: 0px; margin-left: calc(12px / 2); margin-right: calc(12px / 2); } }",
	".framer-ORLXf.framer-v-ldyh1u.framer-1rtq0nx { height: 62px; padding: 0px; width: 350px; }",
	".framer-ORLXf.framer-v-ldyh1u .framer-14gp762 { padding: 20px; }",
	".framer-ORLXf.framer-v-ldyh1u .framer-1s197uu-container, .framer-ORLXf.framer-v-ldyh1u .framer-8oasec { order: 0; }",
	".framer-ORLXf.framer-v-ldyh1u .framer-19moii3, .framer-ORLXf.framer-v-ldyh1u .framer-12hme5w { order: 1; }",
	...css,
	'.framer-ORLXf[data-border="true"]::after, .framer-ORLXf [data-border="true"]::after { content: ""; border-width: var(--border-top-width, 0) var(--border-right-width, 0) var(--border-bottom-width, 0) var(--border-left-width, 0); border-color: var(--border-color, none); border-style: var(--border-style, none); width: 100%; height: 100%; position: absolute; box-sizing: border-box; left: 0; top: 0; border-radius: inherit; pointer-events: none; }',
];
var FramerwvuAi9wiC = withCSS2(Component, css2, "framer-ORLXf");
var stdin_default2 = FramerwvuAi9wiC;
FramerwvuAi9wiC.displayName = "Docs/Search Bar";
FramerwvuAi9wiC.defaultProps = {
	height: 72,
	width: 737,
};
addPropertyControls2(FramerwvuAi9wiC, {
	variant: {
		options: ["jsVKEKG4s", "lBkI6MWTM"],
		optionTitles: ["Desktop", "Mobile"],
		title: "Variant",
		type: ControlType2.Enum,
	},
});
addFonts(
	FramerwvuAi9wiC,
	[
		{
			explicitInter: true,
			fonts: [
				{
					family: "General Sans",
					source: "fontshare",
					style: "normal",
					url: "https://framerusercontent.com/third-party-assets/fontshare/wf/3RZHWSNONLLWJK3RLPEKUZOMM56GO4LJ/BPDRY7AHVI3MCDXXVXTQQ76H3UXA63S3/SB2OEB6IKZPRR6JT4GFJ2TFT6HBB6AZN.woff2",
					weight: "500",
				},
				{
					family: "Inter",
					source: "framer",
					style: "normal",
					unicodeRange:
						"U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F",
					url: "https://framerusercontent.com/assets/5vvr9Vy74if2I6bQ bJvbw7SY1pQ.woff2",
					weight: "400",
				},
				{
					family: "Inter",
					source: "framer",
					style: "normal",
					unicodeRange: "U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116",
					url: "https://framerusercontent.com/assets/EOr0mi4hNtlgWNn9if640EZzXCo.woff2",
					weight: "400",
				},
				{
					family: "Inter",
					source: "framer",
					style: "normal",
					unicodeRange: "U+1F00-1FFF",
					url: "https://framerusercontent.com/assets/Y9k9QrlZAqio88Klkmbd8VoMQc.woff2",
					weight: "400",
				},
				{
					family: "Inter",
					source: "framer",
					style: "normal",
					unicodeRange: "U+0370-03FF",
					url: "https://framerusercontent.com/assets/OYrD2tBIBPvoJXiIHnLoOXnY9M.woff2",
					weight: "400",
				},
				{
					family: "Inter",
					source: "framer",
					style: "normal",
					unicodeRange:
						"U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF",
					url: "https://framerusercontent.com/assets/JeYwfuaPfZHQhEG8U5gtPDZ7WQ.woff2",
					weight: "400",
				},
				{
					family: "Inter",
					source: "framer",
					style: "normal",
					unicodeRange:
						"U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD",
					url: "https://framerusercontent.com/assets/vQyevYAyHtARFwPqUzQGpnDs.woff2",
					weight: "400",
				},
				{
					family: "Inter",
					source: "framer",
					style: "normal",
					unicodeRange:
						"U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB",
					url: "https://framerusercontent.com/assets/b6Y37FthZeALduNqHicBT6FutY.woff2",
					weight: "400",
				},
			],
		},
		...SearchFonts,
		...getFontsFromSharedStyle(fonts),
	],
	{
		supportsExplicitInterCodegen: true,
	},
);

// virtual:docs/search-bar
import { WithFramerBreakpoints } from "unframer";
import { jsx } from "react/jsx-runtime";
var locales = [];
var defaultResponsiveVariants = {
	base: "lBkI6MWTM",
	xl: "jsVKEKG4s",
};
/** @type {function(Props): any} */
function ComponentWithRoot({ locale, ...rest }) {
	return (
		<ContextProviders
			routes={routes}
			framerSiteId={
				"f667fc580d8d9346cf49d633d75940b95292fa43c24dd7765c9a175ec73f7405"
			}
			locale={locale}
			locales={locales}
		>
			{jsx(stdin_default2, {
				...rest,
			})}
		</ContextProviders>
	);
}
/**
 * Renders SearchBarFramerComponent for all breakpoints with a variants map. Variant prop is inferred per breakpoint.
 * @function
 * @memberof SearchBarFramerComponent
 * @param {Omit<Props, 'variant'> & {variants?: VariantsMap}} props
 * @returns {any}
 */
ComponentWithRoot.Responsive = ({ locale, ...rest }) => {
	return (
		<ContextProviders
			routes={routes}
			framerSiteId={
				"f667fc580d8d9346cf49d633d75940b95292fa43c24dd7765c9a175ec73f7405"
			}
			locale={locale}
			locales={locales}
		>
			<WithFramerBreakpoints
				Component={stdin_default2}
				variants={defaultResponsiveVariants}
				{...rest}
			/>
		</ContextProviders>
	);
};
Object.assign(ComponentWithRoot, stdin_default2);
var search_bar_default = ComponentWithRoot;
export { search_bar_default as default };
